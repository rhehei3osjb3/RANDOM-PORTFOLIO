<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Portfolio — Auto GitHub Images</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
<style>
  :root{ --bg1:#020216; --bg2:#07102a; --accent:#ff8800; --muted:#dceffb; --fg:#eaf6ff }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--fg);-webkit-font-smoothing:antialiased}

  /* HERO */
  .hero-overlay{position:fixed;inset:0;z-index:9999;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.02));pointer-events:auto}
  .hero-overlay.fade-out{animation:heroFade .48s ease forwards}
  @keyframes heroFade{to{opacity:0;transform:translateY(-8px) scale(.995)}}

  .hero-inner{max-width:1100px;max-width:92vw;padding:24px;text-align:center;pointer-events:none;display:flex;flex-direction:column;align-items:center;justify-content:center}
  /* Reduced max font size and responsive scaling so the heading never overflows the viewport */
  .hero-text{font-family:Orbitron,Inter,system-ui;font-weight:900;font-size:clamp(22px,6.5vw,56px);line-height:1;color:var(--accent);text-align:center;white-space:nowrap;display:inline-block;overflow:hidden}
  #heroGradient{display:inline-block;transform-origin:center center;transition:transform .18s ease}
  .hero-sub{margin-top:10px;color:#ffffff;font-weight:600;opacity:0.95}
  .char{display:inline-block;opacity:0;transform:translateY(8px);animation:charIn .45s cubic-bezier(.2,.9,.2,1) forwards;margin-right:4px}
  .char.space{width:14px;margin-right:0}
  @keyframes charIn{to{opacity:1;transform:translateY(0)}}

  main{max-width:1200px;margin:120px auto 80px;padding:20px;position:relative;z-index:20;visibility:hidden}
  header{display:flex;flex-direction:column;align-items:center}
  h1{font-family:Orbitron,Inter;margin:6px 0;color:var(--accent);font-size:28px}
  #portfolioSubtitle{color:#ffffff;margin-top:6px}

  /* gallery */
  .gallery{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:22px;margin-top:28px}
  .card{border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,0.04);background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015));box-shadow:0 8px 40px rgba(0,0,0,0.55);cursor:pointer;display:flex;flex-direction:column}
  /* increased frame height to accommodate larger images */
  .frame{height:320px;display:flex;align-items:center;justify-content:center;overflow:hidden;background:#0f0820}
  .frame img{width:100%;height:100%;object-fit:cover;display:block;transition:transform .35s ease,opacity .3s}
  .frame .file-icon{font-size:48px;opacity:0.12}
  .meta{padding:10px 12px;font-size:13px;color:rgba(255,255,255,0.75);display:none}
  .skeleton{width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:rgba(255,255,255,0.06);font-weight:700}

  /* controls */
  .toolbar{display:flex;gap:12px;align-items:center;justify-content:center;margin-top:8px}
  .progress{font-size:13px;color:rgba(255,255,255,0.8)}

  .lightbox{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.9), rgba(0,0,0,0.98));z-index:10001}
  .lightbox.open{display:flex}
  .lightbox img{max-width:94vw;max-height:90vh;border-radius:10px}
  .controls{display:flex;gap:10px;margin-top:8px}
  .controls button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:var(--fg);cursor:pointer}

  footer{color:#064e1b;text-align:center;margin:40px 0 100px}

  @media (max-width:900px){ .frame{height:260px} }
  @media (max-width:640px){ .frame{height:180px} .hero-text{font-size:clamp(18px,9vw,40px)} .char{margin-right:2px} }
</style>
</head>
<body>

<!-- HERO -->
<div class="hero-overlay" id="heroOverlay" aria-hidden="false">
  <div class="hero-inner">
    <div id="heroText" class="hero-text" aria-hidden="false"><span id="heroGradient">WELCOME TO MY PORTFOLIO</span></div>
    <div class="hero-sub" id="heroSub">these are the works i did so far</div>
  </div>
</div>

<main id="mainContent" aria-hidden="true">
  <header>
    <h1>Portfolio</h1>
    <div id="portfolioSubtitle">these are the works i did so far</div>
    <div class="toolbar"><div class="progress" id="progress">Loading…</div></div>
  </header>

  <div class="gallery" id="gallery" aria-live="polite"></div>
  <footer>contact me on discord: user: <strong>random698</strong></footer>
</main>

<!-- lightbox -->
<div class="lightbox" id="lightbox" aria-hidden="true">
  <div style="text-align:center">
    <img id="lightboxImg" alt="zoomed image"/>
    <div class="controls" style="justify-content:center">
      <button id="prevBtn">← Prev</button>
      <button id="nextBtn">Next →</button>
      <button id="closeBtn">Close</button>
    </div>
  </div>
</div>

<script>
// CONFIG: set owner/repo/path if auto-detect doesn't work
const CONFIG_OWNER = "";
const CONFIG_REPO = "";
const CONFIG_PATH = "";
const MAX_IMAGES = 1000; // safety cap
const CACHE_TTL = 6 * 60 * 60 * 1000; // 6 hours

const heroOverlay = document.getElementById('heroOverlay');
const heroGradient = document.getElementById('heroGradient');
const heroSub = document.getElementById('heroSub');
const mainContent = document.getElementById('mainContent');
const gallery = document.getElementById('gallery');
const progressEl = document.getElementById('progress');

const lightbox = document.getElementById('lightbox');
const lightboxImg = document.getElementById('lightboxImg');
const prevBtn = document.getElementById('prevBtn'), nextBtn = document.getElementById('nextBtn'), closeBtn = document.getElementById('closeBtn');

let images = [], allItems = [], currIndex = 0;

/* --- hero split for per-char reveal with larger word gaps --- */
function revealHeroText(){
  const text = heroGradient.textContent.trim();
  heroGradient.innerHTML = text.split('').map(ch => ch === ' ' ? '<span class="char space">&nbsp;</span>' : `<span class="char">${ch}</span>`).join('');
  const chars = [...heroGradient.querySelectorAll('.char')];
  chars.forEach((c,i)=> c.style.animationDelay = (i*28) + 'ms');
  // after characters are inserted, make sure the heading fits the viewport
  adjustHeroScale();
}

function adjustHeroScale(){
  try{
    const g = document.getElementById('heroGradient');
    if(!g) return;
    // reset
    g.style.transform = 'scale(1)';
    const rect = g.getBoundingClientRect();
    const maxW = Math.min(window.innerWidth * 0.92, 1100);
    if(rect.width > maxW){
      const scale = (maxW / rect.width) * 0.98; // a little padding
      g.style.transform = `scale(${scale})`;
    }
  }catch(e){}
}

let resizeTimer = null;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=> adjustHeroScale(), 120);
});

async function hideHeroAfter(ms=4000){
  await new Promise(r => setTimeout(r, ms));
  heroOverlay.classList.add('fade-out');
  await new Promise(r => setTimeout(r, 420));
  try{ heroOverlay.remove(); }catch(e){}
  mainContent.style.visibility = 'visible';
  mainContent.setAttribute('aria-hidden','false');
}

/* --- GitHub helpers --- */
function detectRepo(){
  if(CONFIG_OWNER && CONFIG_REPO) return {owner:CONFIG_OWNER, repo:CONFIG_REPO, path:CONFIG_PATH || ''};
  const host = location.hostname, path = location.pathname;
  if(host.includes('raw.githubusercontent.com')){ const parts = path.split('/').filter(Boolean); if(parts.length>=3) return {owner:parts[0], repo:parts[1], path:parts.slice(3).join('/')||''}; }
  if(host.endsWith('github.io')){ const sub = host.split('.')[0]; const seg = path.split('/').filter(Boolean); if(seg.length>=1) return {owner:sub, repo:seg[0], path:seg.slice(1).join('')||''}; return {owner:sub, repo:sub, path:''}; }
  if(host === 'github.com' || host.endsWith('github.com')){ const seg = path.split('/').filter(Boolean); if(seg.length>=2) return {owner:seg[0], repo:seg[1], path:seg.slice(2).join('/')||''}; }
  return null;
}

async function fetchJson(url, opts={}){
  try{
    const controller = new AbortController();
    const id = setTimeout(()=>controller.abort(), 8000);
    const res = await fetch(url, {...opts, signal:controller.signal});
    clearTimeout(id);
    if(!res.ok) throw new Error('bad');
    return await res.json();
  }catch(e){ return null; }
}

async function fetchRepoTree(owner, repo){
  const api = `https://api.github.com/repos/${owner}/${repo}`;
  const repoJson = await fetchJson(api);
  if(!repoJson) return null;
  const branch = repoJson.default_branch || 'main';
  const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}?recursive=1`;
  const treeJson = await fetchJson(treeUrl);
  if(!treeJson || !Array.isArray(treeJson.tree)) return {branch, tree:[]};
  return {branch, tree: treeJson.tree};
}

function isImagePath(p){ return /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(p); }
function isDisplayable(p){ return isImagePath(p) || /\.(pdf|mp4|webm|mov|txt|md|json|svg)$/i.test(p); }

/* try loading image quickly with timeout */
function probeImage(url, ms=4500){
  return new Promise(resolve=>{
    const img = new Image(); let done=false;
    const timer = setTimeout(()=>{ if(done) return; done=true; img.src=''; resolve(false); }, ms);
    img.onload = ()=>{ if(done) return; done=true; clearTimeout(timer); resolve(true); };
    img.onerror = ()=>{ if(done) return; done=true; clearTimeout(timer); resolve(false); };
    img.src = url + (url.includes('?') ? '&_=' : '?_=') + Date.now();
  });
}

/* cache helpers */
function cacheKey(owner,repo,path){ return `auto-gh:${owner}:${repo}:${path||''}`; }
function saveCache(owner,repo,path,items){ try{ localStorage.setItem(cacheKey(owner,repo,path), JSON.stringify({ts:Date.now(), items})); }catch(e){} }
function loadCache(owner,repo,path){ try{ const raw = localStorage.getItem(cacheKey(owner,repo,path)); if(!raw) return null; const j = JSON.parse(raw); if(!j.ts || !Array.isArray(j.items)) return null; if(Date.now() - j.ts > CACHE_TTL) return null; return j.items; }catch(e){ return null; } }

/* append card for any file (images or generic) */
function appendCard(item){
  // item: {url, path, isImage}
  const card = document.createElement('div'); card.className='card';
  const frame = document.createElement('div'); frame.className='frame';

  if(item.isImage){
    const img = document.createElement('img'); img.loading='lazy'; img.decoding='async'; img.src = item.url; img.alt = item.path.split('/').pop();
    img.addEventListener('load', ()=> img.style.opacity = 1);
    img.addEventListener('error', ()=>{
      frame.innerHTML = `<div class=\"skeleton\">broken image</div>`;
    });
    frame.appendChild(img);
  } else {
    // generic file: show a lightweight icon and link
    frame.innerHTML = `<div style=\"text-align:center;padding:18px;color:rgba(255,255,255,0.9)\"><div class=\"file-icon\">📄</div><div style=\"margin-top:8px;font-size:13px;color:rgba(255,255,255,0.75)\">${item.path.split('/').pop()}</div></div>`;
    frame.addEventListener('click', ()=> window.open(item.url, '_blank'));
  }

  card.appendChild(frame);
  // clicking opens lightbox for images, raw for others
  card.addEventListener('click', ()=>{
    if(item.isImage){
      openLightboxBySrc(item.url);
    } else {
      window.open(item.url, '_blank');
    }
  });

  gallery.appendChild(card);
}

/* open lightbox */
function openLightboxBySrc(src){ currIndex = images.indexOf(src); lightboxImg.src = src; lightbox.classList.add('open'); document.body.style.overflow='hidden'; }
function closeLightbox(){ lightbox.classList.remove('open'); document.body.style.overflow='auto'; }
function nextImg(){ if(!images.length) return; currIndex = (currIndex+1)%images.length; lightboxImg.src = images[currIndex]; }
function prevImg(){ if(!images.length) return; currIndex = (currIndex-1+images.length)%images.length; lightboxImg.src = images[currIndex]; }
prevBtn.addEventListener('click', prevImg); nextBtn.addEventListener('click', nextImg); closeBtn.addEventListener('click', closeLightbox);
document.addEventListener('keydown', e=>{ if(lightbox.classList.contains('open')){ if(e.key==='Escape') closeLightbox(); if(e.key==='ArrowRight') nextImg(); if(e.key==='ArrowLeft') prevImg(); } });

/* --- main loader: fetch tree, pick candidates, probe concurrently, append quickly --- */
async function loadRepo(owner,repo,path){
  progressEl.style.display = '';
  progressEl.textContent = 'Scanning repository...';
  const cached = loadCache(owner,repo,path);
  if(cached && cached.length){
    // show cached quickly
    gallery.innerHTML = '';
    images = [];
    for(const it of cached){ appendCard(it); if(it.isImage) images.push(it.url); }
    progressEl.textContent = `Loaded from cache — ${cached.length} files`;
  }

  const t = await fetchRepoTree(owner,repo);
  if(!t){ progressEl.textContent = 'Could not read repository (rate-limited or not found)'; return; }

  // pick blobs under path
  const folderPrefix = path ? path.replace(/^\/*/,'') + '/' : '';
  const blobs = t.tree.filter(n => n.type === 'blob' && (!folderPrefix || n.path.startsWith(folderPrefix)));
  if(!blobs.length){ progressEl.textContent = 'No files found in repository.'; return; }

  // prefer obvious assets first (images) — sort to try images earlier
  const items = blobs.map(b=>({path:b.path, isImage:isImagePath(b.path), url:`https://raw.githubusercontent.com/${owner}/${repo}/${t.branch}/${b.path}`})).filter(it=>isDisplayable(it.path) || it.isImage);
  allItems = items;
  progressEl.textContent = `Found ${items.length} files — validating...`;

  // concurrency probe
  let idx = 0; const concurrency = 18; const validated = [];
  async function worker(){
    while(idx < items.length && validated.length < MAX_IMAGES){
      const i = idx++; const it = items[i];
      // probe images quickly, for other files accept immediately
      if(it.isImage){
        const ok = await probeImage(it.url, 4000);
        // if ok show as image, if not, still show a link card (so "all uploaded files appear")
        const cardItem = {url:it.url, path:it.path, isImage: !!ok};
        validated.push(cardItem);
        appendCard(cardItem);
        if(cardItem.isImage) images.push(cardItem.url);
      } else {
        // non-image: append as link (fast)
        const cardItem = {url:it.url, path:it.path, isImage:false};
        validated.push(cardItem);
        appendCard(cardItem);
      }
      progressEl.textContent = `Validated ${validated.length} / ${items.length}`;
    }
  }
  await Promise.all(Array.from({length:concurrency}, ()=>worker()));

  // save cache
  try{ saveCache(owner,repo,path,validated); }catch(e){}
  // remove the final "Done — X files shown" text and hide the progress element (user requested removal)
  try{ progressEl.textContent = ''; progressEl.style.display = 'none'; }catch(e){}
}

/* boot sequence */
async function boot(){
  revealHeroText();
  const auto = detectRepo();
  let owner=null, repo=null, path='';
  if(auto){ owner = auto.owner; repo = auto.repo; path = (CONFIG_PATH || auto.path || '').replace(/^\/*/,''); }
  if(CONFIG_OWNER && CONFIG_REPO){ owner = CONFIG_OWNER; repo = CONFIG_REPO; path = CONFIG_PATH || path; }

  // start scanning early while hero still showing — don't block hero timing
  if(owner && repo){ loadRepo(owner,repo,path).catch(()=>{}); }
  await hideHeroAfter(4000);
}

document.addEventListener('DOMContentLoaded', ()=> boot());

</script>
</body>
</html>
